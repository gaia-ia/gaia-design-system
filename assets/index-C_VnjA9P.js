import{r,a as p}from"./index-GiUgBvb1.js";import{j as z}from"./jsx-runtime-CDt2p4po.js";function M(t,e,{checkForDefaultPrevented:o=!0}={}){return function(u){if(t==null||t(u),o===!1||!u.defaultPrevented)return e==null?void 0:e(u)}}function j(t,e=[]){let o=[];function i(c,n){const s=r.createContext(n),f=o.length;o=[...o,n];const S=a=>{var m;const{scope:d,children:x,...v}=a,b=((m=d==null?void 0:d[t])==null?void 0:m[f])||s,C=r.useMemo(()=>v,Object.values(v));return z.jsx(b.Provider,{value:C,children:x})};S.displayName=c+"Provider";function l(a,d){var b;const x=((b=d==null?void 0:d[t])==null?void 0:b[f])||s,v=r.useContext(x);if(v)return v;if(n!==void 0)return n;throw new Error(`\`${a}\` must be used within \`${c}\``)}return[S,l]}const u=()=>{const c=o.map(n=>r.createContext(n));return function(s){const f=(s==null?void 0:s[t])||c;return r.useMemo(()=>({[`__scope${t}`]:{...s,[t]:f}}),[s,f])}};return u.scopeName=t,[i,w(u,...e)]}function w(...t){const e=t[0];if(t.length===1)return e;const o=()=>{const i=t.map(u=>({useScope:u(),scopeName:u.scopeName}));return function(c){const n=i.reduce((s,{useScope:f,scopeName:S})=>{const a=f(c)[`__scope${S}`];return{...s,...a}},{});return r.useMemo(()=>({[`__scope${e.scopeName}`]:n}),[n])}};return o.scopeName=e.scopeName,o}var h=globalThis!=null&&globalThis.document?r.useLayoutEffect:()=>{},y=p[" useId ".trim().toString()]||(()=>{}),P=0;function A(t){const[e,o]=r.useState(y());return h(()=>{o(i=>i??String(P++))},[t]),t||(e?`radix-${e}`:"")}function D(t){const e=r.useRef(t);return r.useEffect(()=>{e.current=t}),r.useMemo(()=>(...o)=>{var i;return(i=e.current)==null?void 0:i.call(e,...o)},[])}var $=p[" useInsertionEffect ".trim().toString()]||h;function B({prop:t,defaultProp:e,onChange:o=()=>{},caller:i}){const[u,c,n]=g({defaultProp:e,onChange:o}),s=t!==void 0,f=s?t:u;{const l=r.useRef(t!==void 0);r.useEffect(()=>{const a=l.current;a!==s&&console.warn(`${i} is changing from ${a?"controlled":"uncontrolled"} to ${s?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),l.current=s},[s,i])}const S=r.useCallback(l=>{var a;if(s){const d=R(l)?l(t):l;d!==t&&((a=n.current)==null||a.call(n,d))}else c(l)},[s,t,c,n]);return[f,S]}function g({defaultProp:t,onChange:e}){const[o,i]=r.useState(t),u=r.useRef(o),c=r.useRef(e);return $(()=>{c.current=e},[e]),r.useEffect(()=>{var n;u.current!==o&&((n=c.current)==null||n.call(c,o),u.current=o)},[o,u]),[o,i,c]}function R(t){return typeof t=="function"}var _=r.createContext(void 0);function O(t){const e=r.useContext(_);return t||e||"ltr"}function k(t){const[e,o]=r.useState(void 0);return h(()=>{if(t){o({width:t.offsetWidth,height:t.offsetHeight});const i=new ResizeObserver(u=>{if(!Array.isArray(u)||!u.length)return;const c=u[0];let n,s;if("borderBoxSize"in c){const f=c.borderBoxSize,S=Array.isArray(f)?f[0]:f;n=S.inlineSize,s=S.blockSize}else n=t.offsetWidth,s=t.offsetHeight;o({width:n,height:s})});return i.observe(t,{box:"border-box"}),()=>i.unobserve(t)}else o(void 0)},[t]),e}function L(t){const e=r.useRef({value:t,previous:t});return r.useMemo(()=>(e.current.value!==t&&(e.current.previous=e.current.value,e.current.value=t),e.current.previous),[t])}export{B as a,D as b,j as c,M as d,A as e,h as f,L as g,k as h,O as u};
